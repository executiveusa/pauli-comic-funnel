/**
 * Validator Agent: Code Review for Adversarial Review System
 *
 * Purpose: Strictly review code generated by Coder Agent
 * Approach: Find issues, suggest improvements, enforce standards
 *
 * Created: 2025-12-30
 * Author: Claude Code
 */

import type { CodeGenerationResult } from './coder-agent';

export interface ReviewCriteria {
  codeQuality: boolean;
  security: boolean;
  performance: boolean;
  testCoverage: boolean;
  documentation: boolean;
  conventions: boolean;
}

export interface ReviewResult {
  approved: boolean;
  score: number; // 0-100
  issues: Array<{
    severity: 'critical' | 'high' | 'medium' | 'low';
    category: keyof ReviewCriteria;
    description: string;
    suggestion: string;
    location?: string;
  }>;
  suggestions: string[];
  mustFix: string[];
  iteration: number;
  nextSteps: string;
}

export class ValidatorAgent {
  private agentId = 'VALIDATOR-AGENT';
  private passingScore = 90; // Code must score 90+ to pass

  /**
   * Review code generated by Coder Agent
   */
  async reviewCode(
    code: CodeGenerationResult,
    iteration: number = 1
  ): Promise<ReviewResult> {
    console.log(`[VALIDATOR-AGENT] Reviewing code (iteration ${iteration})`);

    const issues: ReviewResult['issues'] = [];
    const suggestions: string[] = [];
    const mustFix: string[] = [];

    // Review criteria
    const criteria = this.evaluateCriteria(code);

    // Check code quality
    if (!criteria.codeQuality) {
      issues.push({
        severity: 'high',
        category: 'codeQuality',
        description: 'Code quality below standards',
        suggestion: 'Refactor for clarity, remove duplications, improve naming'
      });
      mustFix.push('Improve code quality');
    }

    // Check security
    if (!criteria.security) {
      issues.push({
        severity: 'critical',
        category: 'security',
        description: 'Security vulnerabilities detected',
        suggestion: 'Address SQL injection, XSS, authentication issues'
      });
      mustFix.push('Fix security vulnerabilities');
    }

    // Check performance
    if (!criteria.performance) {
      issues.push({
        severity: 'medium',
        category: 'performance',
        description: 'Performance concerns identified',
        suggestion: 'Optimize algorithms, reduce complexity'
      });
      suggestions.push('Consider performance optimizations');
    }

    // Check test coverage
    if (!criteria.testCoverage) {
      issues.push({
        severity: 'high',
        category: 'testCoverage',
        description: 'Insufficient test coverage',
        suggestion: 'Add unit tests, integration tests, edge case coverage'
      });
      mustFix.push('Add comprehensive tests');
    }

    // Check documentation
    if (!criteria.documentation) {
      issues.push({
        severity: 'medium',
        category: 'documentation',
        description: 'Documentation incomplete',
        suggestion: 'Add JSDoc comments, README, usage examples'
      });
      suggestions.push('Improve documentation');
    }

    // Check conventions
    if (!criteria.conventions) {
      issues.push({
        severity: 'low',
        category: 'conventions',
        description: 'Code conventions not followed',
        suggestion: 'Follow project naming conventions, file structure'
      });
      suggestions.push('Follow project conventions');
    }

    // Calculate score
    const score = this.calculateScore(criteria, issues);

    // Determine approval
    const approved = score >= this.passingScore && mustFix.length === 0;

    // Determine next steps
    let nextSteps: string;
    if (approved) {
      nextSteps = 'Code approved - ready for merge';
    } else if (iteration >= 5) {
      nextSteps = 'Maximum iterations reached - escalate to human review';
    } else {
      nextSteps = `Address ${mustFix.length} critical issues and iterate`;
    }

    return {
      approved,
      score,
      issues,
      suggestions,
      mustFix,
      iteration,
      nextSteps
    };
  }

  /**
   * Evaluate code against all criteria
   */
  private evaluateCriteria(code: CodeGenerationResult): ReviewCriteria {
    // Simplified evaluation - in production would use static analysis tools
    const hasTests = Boolean(code.tests && code.tests.length > 50);
    const hasDocs = Boolean(code.documentation && code.documentation.length > 50);
    const hasGoodQuality = code.metadata.estimatedQuality >= 70;

    return {
      codeQuality: hasGoodQuality,
      security: true, // Assume secure for now - would use security scanner
      performance: true, // Assume performant for now - would use profiler
      testCoverage: hasTests,
      documentation: hasDocs,
      conventions: true // Assume conventions followed - would use linter
    };
  }

  /**
   * Calculate overall score
   */
  private calculateScore(criteria: ReviewCriteria, issues: ReviewResult['issues']): number {
    // Start with base score from criteria
    const criteriaScore = Object.values(criteria).filter(Boolean).length / Object.keys(criteria).length * 100;

    // Deduct points for issues
    const deductions = issues.reduce((total, issue) => {
      const severityDeductions = {
        critical: 30,
        high: 15,
        medium: 5,
        low: 2
      };
      return total + severityDeductions[issue.severity];
    }, 0);

    return Math.max(0, Math.min(100, criteriaScore - deductions));
  }

  /**
   * Generate improvement suggestions
   */
  generateImprovementPrompt(review: ReviewResult): string {
    if (review.approved) {
      return 'Code approved - no improvements needed';
    }

    let prompt = 'Please address the following issues:\n\n';

    if (review.mustFix.length > 0) {
      prompt += '## Critical Issues (Must Fix)\n';
      review.mustFix.forEach((issue, i) => {
        prompt += `${i + 1}. ${issue}\n`;
      });
      prompt += '\n';
    }

    if (review.issues.length > 0) {
      prompt += '## Detailed Issues\n';
      review.issues.forEach((issue, i) => {
        prompt += `\n### ${i + 1}. ${issue.description} (${issue.severity})\n`;
        prompt += `**Category**: ${issue.category}\n`;
        prompt += `**Suggestion**: ${issue.suggestion}\n`;
        if (issue.location) {
          prompt += `**Location**: ${issue.location}\n`;
        }
      });
    }

    prompt += `\n## Current Score: ${review.score}/100 (Need ${this.passingScore}+ to pass)\n`;
    prompt += `## Iteration: ${review.iteration}/5\n`;
    prompt += `\n${review.nextSteps}`;

    return prompt;
  }
}

export const validatorAgent = new ValidatorAgent();
